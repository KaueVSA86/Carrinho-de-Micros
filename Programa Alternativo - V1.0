;============================================;
;     PROJETO FINAL - MICROPROCESSADORES     ;
;	      CARRINHO MAPEADOR	             ;
;============================================;
; Equipe CAOS:			             ;   
;   Kauê Almeida - 570004      (Programador) ;   
;   Israel Medeiros - 570948   (Programador) ;   
;   Douglas Fabiano - 570151      (Designer) ;   
;   Pedro Coutinho - 		             ;   
;   João Gabriel - 		  (Mêcânico) ;   
;============================================; 
    
;========================================;
;      	PINOUT - PIC - PERIFÉRICOS	 ;
;========================================;    
;		 DRIVER		         ;   
;----------------------------------------;      
; - EN_1: RD7	                  	 ;   
; - EN_2: RD6	    	                 ;
; - EN_3: RD5				 ;    
; - EN_4: RD4				 ;    
; - PWM_A: CCP1 (RC2)			 ;   
; - PWM_B: CCP2 (RC1)			 ;	
;----------------------------------------;
;		SENSORES	      	 ;
;----------------------------------------;
; - SENSOR FRENTE: RB4		         ;
; - PINO LIVRE: RB5                      ;
;----------------------------------------;    
;	    BOTÕES DE CONTROLE           ; 
;----------------------------------------;
; - MODO: RB6	     (Mapeamento ou Run) ;
; - SELEÇÃO: RB7    (Prioridade ou Stop) ;
;========================================;

#INCLUDE <P16F877A.INC>        
__CONFIG _HS_OSC & _WDT_OFF & _LVP_OFF & _CP_OFF & _CPD_OFF

;========================================;
;	        VARIÁVEIS	         ;
;========================================;    
  CBLOCK 0x20
    CPASSO_D ; Contador de Passo da Direita
    CPASSO_E ; Contador de Passo da Esquerda

    F_ESQ    ; Flag da esquerda
    F_DIR    ; Flag da direita

    GIRO     ; Valor de Giro (90°)
    GIRO_OP  ; Operador do Giro

    PASSO    ; Valor do Passo (A definir)
    PASSO_OP ; Operador do Passo
    
    MERDA    ; Flag de verificação do caminho ao lado
    
  ENDC      
;========================================;
   
ORG 0x000
GOTO MAIN
  
;========================================;
;	   VETOR DE INTERRUPÇÃO          ;
;========================================;      
ORG 0x004

BANKSEL PORTD
MOVLW b'00000000'   ; Desliga todos os motores
MOVWF PORTD         ; Manda o comando de desligar os motores para portd
  
BCF INTCON, 1  	    ; Desativa a  flag da interrupção externa

BCF F_ESQ, 0	    ; Limpa a flag de controle de giro esqueda (prioridade a direita)
BTFSS PORTB, 7	    ; Verifica qual a prioridade
BSF F_ESQ, 0        ; Ativa a flag de controle de giro esquerdo (prioridade a esquerda)


  
  
RETFIE
    
MAIN:
    
;=================================;
;      CONFIGURAÇÃO INICIAL	  ;
;=================================;
; Preecher valor das variáveis
BANKSEL ADCON0

MOVLW d'100'	; Valor inicial do Giro
MOVWF GIRO

MOVLW d'150'	; Valor inicial do Passo
MOVWF PASSO
        
CLRF CPASSO_D	; Valor inicial do contador de passso direito
CLRF CPASSO_E   ; Valor inicial do contador de passo esquerdo 
CLRF F_ESQ      ; Valor inicial da flag esquerda
    
; Configuração do sentido das portas
BANKSEL TRISB
MOVLW b'11100001'    ; Pinos de Entrada: 0, 4, 5, 6, 7    -  Pinos de Saída: Restante
MOVWF TRISB
    
MOVLW b'00000000'    ; Pinos de Saída: Todos     
MOVWF TRISC

MOVLW b'00000000'    ; Pinos de Saída: Todos    
MOVWF TRISD

BCF OPTION_REG, 7   ; habilita pull-ups PORTB        

BANKSEL PORTD
MOVLW b'00000000'
MOVWF PORTD    
    
; Configuração das interrupções    
MOVLW b'10010000'    ; Ativa a interrupção global - Restante das interrupções ficam desativadas
MOVWF INTCON
BSF OPTION_REG, 6   ; Ativa a interrupção por borda de subida

;Configurações do timer e do dutycycle    
BANKSEL T2CON	
MOVLW   b'00000111'   ; Postscale = 0, TMR2ON = 1, Prescaler = 16
MOVWF   T2CON

; Período do PWM
MOVLW   d'124'	      ; Valor do PR2
MOVWF   PR2    
    
MOVLW   b'00001100'   ; Ativa o modo PWM do CCP1 e CCP2
MOVWF   CCP1CON    
MOVWF   CCP2CON
    
; Duty Cycle = 50% (128)
MOVLW   d'64'
MOVWF   CCPR1L
MOVWF   CCPR2L    
    
    
;=================================;    
    
    

;=================================;
;	  SELEÇÃO DE MODO         ;
;=================================;

MODO:			; Função de seleção do modo (exploração ou seguimento)
    
    BANKSEL PORTD
    MOVLW b'00000000'	; Garantia de que o carrinho inicie parado
    MOVWF PORTD
    
    BTFSC PORTB, 6	; Se = 0 pula a linha e vai pro modo parado ou seguimento
    GOTO FRENTE		; Se = 1 vai pro modo de mapeamento 
    
    BTFSS PORTB, 7	; Testa o bit 7 da portb
    GOTO PARADO		; Se = 0 modo parado
    GOTO CAMINHO	; Se = 1 modo frente

PARADO:
    BANKSEL PORTD
    MOVLW b'00000000'
    MOVWF PORTD
GOTO MODO
        
;=================================;
    
    
    
    
;===================================================;
;	 FUNÇÃO PARA GERAR INTERRUPÇÃO EXTERNA	    ;
;===================================================;	    
GERA_INT:		; Preparado pra lógica normal (sensor = 1)    
    
    BANKSEL PORTB
    BCF PORTB, 3	; Valor incial de RB3 = 0 
    
    BTFSC PORTB, 4	; Se RB4 = 0, CONTINUA
    BSF PORTB, 3	; RB3 = 1
    
    BTFSS PORTB, 4
    GOTO NSABO
    
    BTFSS F_ESQ, 0	; Verifica se a flag da esquerda foi ativada
    GOTO DIREITA
    GOTO ESQUERDA
  
NSABO:
    
    BTFSC PORTB, 4
    GOTO GIRAR180
    
    BCF F_ESQ, 0        ; Limpa a flag esquerda
    BCF PORTB, 3        ; Valor final para RB3 = 0
    
RETURN    
;===================================================;    
    
    
;===================================================;
;	   BLOCO PRINCIPAL DE IR PARA FRENTE	    ;
;===================================================;	            
FRENTE:

BANKSEL PORTD

MOVF PASSO, 0		 ; Move o valor da variável passo para W
MOVWF PASSO_OP		 ; Move o valor em W para o operador de passo 

MOVF GIRO,0	         ; Move o valor da variável giro para W
MOVWF GIRO_OP		 ; Move o valor em W para o operador de giro
		 		 
CALL GERA_INT		 ; Chama a função de verificar a interrupção    

MOVLW b'10100000'	 ; Move o valor para W
MOVWF PORTD		 ; Move o valor de W para portd (ligar os motores)

LUPASSO:

BTFSS PORTB, 6		 ; Verifica se mudou de estado a chave principal
GOTO MODO	         ; Vai pra função modo

DECF PASSO_OP		 ; Decrementa o operador de passo
MOVF PASSO_OP, 0	 ; Move para W
SUBLW 0			 ; Subtrai por 0

BTFSS STATUS, Z		 ; Verifica se já acabou o loop
GOTO LUPASSO		 ; Retorna para a rotina de ir pra frente

BTFSS PORTB, 6		 ; Gambiarra   
GOTO OLHA
BTFSS PORTB, 7		 ; Verifica qual a prioridade  
GOTO PASSO_E		 ; Chama a função de adicionar passo ao contador esquerdo
GOTO PASSO_D		 ; Chama a função de adicionar passo ao contador direito


; ------------- Rotina de olhar pros lados pós passo ------------- ;     

OLHA:    
    
;BTFSS PORTB, 7
;GOTO OLHADA_ESQUERDA
;GOTO OLHADA_DIREITA    
    
GOTO FRENTE		 ; LOOP FUNÇÃO FRENTE

;---------------------------------------------------;
    
    
;===================================================;
;		 BLOCOS DE ROTAÇÃO	            ;
;===================================================;
      
   
ESQUERDA:
    BANKSEL PORTD
    MOVLW b'10010000'	 ; Liga o motor esquerdo e inverte o direito
    MOVWF PORTD
    
    LUESQUERDA:
    
    DECF GIRO_OP	 ; Decrementa a função giro
    MOVF GIRO_OP,0	 ; Move de Giro_OP para W
    SUBLW 0		 ; Subtrai 0 para ver se chegou ao limite ou seja giro_op = 0
    
    BTFSS STATUS, Z	 ; Se Z = 1 --> NSABO (Giro completo), caso Z = 0 --> Retorna para o loop da esquerda
    GOTO LUESQUERDA	 ; Loop até o giro acabar
    GOTO NSABO		 ; Volta pro NSABO

DIREITA:
    BANKSEL PORTD
    MOVLW b'01100000'	 ; Liga o motor esquerdo e inverte o direito
    MOVWF PORTD 
    
    LUDIREITA:

    DECF GIRO_OP	 ; Decrementa a função giro
    MOVF GIRO_OP,0	 ; Move de Giro_OP para W
    SUBLW 0		 ; Subtrai 0 para ver se chegou ao limite ou seja giro_op = 0
    
    BTFSS STATUS, Z	 ; Se Z = 1 --> NSABO (Giro completo), caso Z = 0 --> Retorna para o loop da esquerda
    GOTO LUDIREITA       ; Loop até o giro acabar
    GOTO NSABO		 ; Volta pro NSABO
    
    
GIRAR180:
    BANKSEL PORTD
    MOVF GIRO,0	         ; Move o valor da variável giro para W
    MOVWF GIRO_OP	 ; Move o valor em W para o operador de giro
    ADDWF GIRO_OP, 1	 ; fazer o dobro da variável giro
    
    MOVLW b'01100000'	 ; Liga o motor esquerdo e inverte o direito
    MOVWF PORTD 
    
    LUGIRA:

    DECF GIRO_OP	 ; Decrementa a função giro
    MOVF GIRO_OP,0	 ; Move de Giro_OP para W
    SUBLW 0		 ; Subtrai 0 para ver se chegou ao limite ou seja giro_op = 0
    
    BTFSS STATUS, Z	 ; Se Z = 1 --> NSABO (Giro completo), caso Z = 0 --> Retorna para o loop da esquerda
    GOTO LUGIRA		 ; Loop até o giro acabar
    GOTO NSABO		 ; Volta pro NSABO
    
    
;===================================================;
;	  FUNÇÃO PARA INCREMENTAR OS PASSOS	    ;
;===================================================;	        
PASSO_D:
    BANKSEL PORTB
    BTFSC PORTB,6 
    INCF CPASSO_D
    GOTO FRENTE
;---------------------------------------------------;
PASSO_E:
    BANKSEL PORTB
    BTFSC PORTB, 6
    INCF CPASSO_E
    GOTO FRENTE
;===================================================;   
        
 
;===================================================;
;                   MELHOR CAMINHO                  ;
;===================================================;	        
 CAMINHO:
    
 ; Lógica de Subtração dos Passos: Esquerda - Direita   
 MOVLW  CPASSO_D      ; W = CPASSO_D
 SUBLW  CPASSO_E      ; W = C_PASSO_E - CPASSO_D
 
 ; Caso onde PASSOE = PASSOD
 BTFSC STATUS, Z 
 GOTO PARADO
 
 BCF PORTB, 5	    ; OFF na flag do melhor caminho esquerda
 ; se chegou aqui, os valores são diferentes...
 BTFSS STATUS, C    ; Se ESQ > DIR, C = 1
 BSF PORTB, 5	    ; Seta a flag do melhor caminho esquerda
 GOTO FRENTE 
 
END


 
 
 ; Lógica do melhor caminho certa, agora falta implementar na rotina frente
 ; Criar lógica de olhar pro lado
 
 
 ; Retirei a flag dir, inutil na lógica do código
 ; Corrigi o teste de Z na escolha do melhor caminho
 ; Corrigi o sentido dos pinos do driver
