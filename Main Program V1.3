;============================================;
;     PROJETO FINAL - MICROPROCESSADORES     ;
;	            CARRINHO MAPEADOR	         ;
;============================================;
; Equipe CAOS:				                 ;   
;   Kauê Almeida - 570004      (Programador) ;   
;   Israel Medeiros - 570948   (Programador) ;   
;   Douglas Fabiano - 570151      (Designer) ;   
;   Pedro Coutinho - 			             ;   
;   João Gabriel - 			                 ;   
;============================================; 
    
;========================================;
;      	PINOUT - PIC - PERIFÉRICOS	     ;
;========================================;    
;		         DRIVER		             ;   
;----------------------------------------;      
; - EN_A1: RD7	                  		 ;   
; - EN_A2: RD6	    	                 ;
; - EN_B1: RD5				             ;    
; - EN_B2: RD4				             ;    
; - PWM_A: CCP1 (RC2)			         ;   
; - PWM_B: CCP2 (RC1)			         ;	
;----------------------------------------;
;		         SENSORES	          	 ;
;----------------------------------------;
; - SENSOR FRENTE: RB4		             ;
; - SENSOR TRÁS: RB5                     ;
;----------------------------------------;    
;	        BOTÕES DE CONTROLE           ; 
;----------------------------------------;
; - MODO: RB6	     (Mapeamento ou Run) ;
; - SELEÇÃO: RB7	(Prioridade ou Stop) ;
;========================================;
    
;========================================;
;		        VARIÁVEIS		         ;
;========================================;    
  CBLOCK 0x20
    CPASSO_D ; Contador de Passo da Direita
    CPASSO_E ; Contador de Passo da Esquerda

    F_ESQ    ; Flag da esquerda
    F_DIR    ; Flag da direita

    GIRO     ; Valor de Giro (90°)
    GIRO_OP  ; Operador do Giro

    PASSO    ; Valor do Passo (A definir)
    PASSO_OP ; Operador do Passo
    
    DUTY_A  
    DUTY_B
    
    PR2
    PRESCALE
  ENDC      
;========================================;
   
  
  
#INCLUDE <P16F877A.INC>    
    
ORG 0x000
GOTO MAIN
  
;========================================;
;	        VETOR DE INTERRUPÇÃO	     ;
;========================================;      
ORG 0x004

BANKSEL PORTD
MOVLW '00000000'    ; Desliga todos os motores
MOVWF PORTD         ; Manda o comando de desligar os motores para portd

BCF INTCON, 1  	    ; Desativa a  flag da interrupção externa
BTFSS PORTB, 7	    ; Verifica qual a prioridade
BSF F_ESQ, 0        ; Ativa a flag de controle de giro esquerdo
BSF F_DIR, 0        ; Ativa a flag de controle de giro direito  
  
RETFIE
    
MAIN:
    
;=================================;
;      CONFIGURAÇÃO INICIAL	      ;
;=================================;
; Preecher valor das variáveis
BANKSEL ADCON0

MOVLW 50	; Valor inicial do Giro
MOVWF GIRO

MOVLW 200	; Valor inicial do Passo
MOVWF PASSO
    
MOVLW 50	; Valor pro dutyA
MOVWF DUTY_A    
    
MOVLW 50	; Valor pro dutyB 
MOVWF DUTY_B    
    
MOVLW 50	; Valor pro PR2
MOVWF PR2
    
MOVLW 50	; Valor do Prescale
MOVWF PRESCALE
   
CLRF CPASSO_D	; Valor inicial do contador de passso direito
CLRF CPASSO_E   ; Valor inicial do contador de passo esquerdo 
CLRF F_DIR      ; Valor inical da flag direita
CLRF F_ESQ      ; Valor incial da flag esquerda

    
; Configuração do sentido das portas
BANKSEL TRISB
MOVLW '11110001'    ; Pinos de Entrada: 0, 4, 5, 6, 7    -  Pinos de Saída: Restante
MOVWF TRISB
    
MOVLW '00000000'    ; Pinos de Saída: Todos     
MOVWF TRISC

MOVLW '00000000'    ; Pinos de Saída: Todos    
MOVWF TRISD
    
; Configuração das interrupções    
MOVLW '10010000'    ; Ativa a interrupção global - Restante das interrupções ficam desativadas
MOVWF INTCON
BSF OPTION_REG, 6   ; Ativa a interrupção por borda de subida

;Configurações do timer e do dutycycle    
BANKSEL T2CON	
MOVLW '00000100'    ; Ajusta o pré (1:1) & post scale (1:1) e liga o TMR2
MOVWF T2CON

;=================================;    
    
    

;=================================;
;	       SELEÇÃO DE MODO	      ;
;=================================;

MODO:	;função de seleção do modo (exploração ou seguimento)
    
    BANKSEL PORTD
    MOVLW '00000000' ; Garantia de que o carrinho inicie parado
    MOVWF PORTD
    
    BTFSC PORTB, 6	; Se = 0 pula a linha e vai pro modo parado ou seguimento
    GOTO CAMINHO    ; Se = 1 vai pro modo de mapeamento 
    
    BTFSS PORTB, 7	; Testa o bit 7 da portb
    GOTO PARADO		; Se = 0 modo parado
    GOTO FRENTE     ; Se = 1 modo frente

PARADO:
    MOVLW '00000000'
    MOVWF PORTD
GOTO MODO
        
;=================================;
    
    
    
    
;===================================================;
;	      FUNÇÃO PARA GERAR INTERRUPÇÃO EXTERNA	    ;
;===================================================;	    
GERA_INT:   ; Preparado pra lógica invertida (sensor = 0)    
    
    BCF PORTB, 3     ; Valor incial de RB3 = 0 
    
    BTFSS PORTB, 4   ; Se RB4 = 1
    BSF PORTB, 3     ; RB3 = 1

    BTFSS PORTB, 5   ; Se RB5 = 1
    BSF PORTB, 3     ; RB3 = 1

    BTFSS PORTB, 3   ; Se RB3 = 0, retorna ao programa, caso contrário irá verificar qual flag foi ativa
    GOTO NSABO           

    BTFSS F_ESQ, 0   ; Verifica se a flag da esquerda foi ativada
    GOTO DIREITA
    GOTO ESQUERDA
  
    NSABO:
    
    BCF F_DIR        ; Limpa a flag direita
    BCF F_ESQ        ; Limpa a flag esquerda
    BCF PORTB, 3     ; Valor final para RB3 = 0
    
RETURN    
;===================================================;    

    
;===================================================;
;	       BLOCO PRINCIPAL DE IR PARA FRENTE	    ;
;===================================================;	            
FRENTE:

BANKSEL PORTD

MOVF PASSO, 0        ; Move o valor da variável passo para W
MOVWF PASSO_OP       ; Move o valor em W para o operador de passo 

MOVF GIRO,0	         ; Move o valor da variável giro para W
MOVWF GIRO_OP	     ; Move o valor em W para o operador de giro
    
CALL GERA_INT	     ; Chama a função de verificar a interrupção    

MOVLW '10010000'     ; Move o valor para W
MOVWF PORTD          ; Move o valor de W para portd (ligar os motores)

LUPASSO:

BTFSS PORTB, 6	    ; Verifica se mudou de estado a chave principal
GOTO MODO	        ; Vai pra função modo

DEC PASSO_OP        ; Decrementa o operador de passo
MOVF PASSO_OP, 0    ; Move para W
SUBLW 0             ; Subtrai por 0

BTFSS STATUS, Z     ; Verifica se já acabou o loop
GOTO LUPASSO        ; Retorna para a rotina de ir pra frente

BTFSS PORTB, 7      ; Verifica qual a prioridade  
GOTO PASSO_E        ; Chama a função de adicionar passo ao contador esquerdo
GOTO PASSO_D	    ; Chama a função de adicionar passo ao contador direito


;---------------------------------------------------;
    
    
;===================================================;
;		          BLOCOS DE ROTAÇÃO		            ;
;===================================================;
    
ESQUERDA:
    BANKSEL PORTD
    MOVLW '01010000'  ; Liga o motor esquerdo e inverte o direito
    MOVWF PORTD

    LUESQUERDA:
    
    DEC GIRO_OP		  ; Decrementa a função giro
    MOVF GIRO_OP,0	  ; Move de Giro_OP para W
    SUBLW 0		      ; Subtrai 0 para ver se chegou ao limite ou seja giro_op = 0
    
    BTFSS STATUS, Z	  ; Se Z = 1 --> NSABO (Giro completo), caso Z = 0 --> Retorna para o loop da esquerda
    GOTO LUESQUERDA   ; Loop até o giro acabar
    GOTO NSABO        ; Volta pro NSABO

DIREITA:
    BANKSEL PORTD
    MOVLW '10100000'  ; Liga o motor esquerdo e inverte o direito
    MOVWF PORTD

    LUDIREITA:

    DEC GIRO_OP		  ; Decrementa a função giro
    MOVF GIRO_OP,0	  ; Move de Giro_OP para W
    SUBLW 0		      ; Subtrai 0 para ver se chegou ao limite ou seja giro_op = 0
    
    BTFSS STATUS, Z	  ; Se Z = 1 --> NSABO (Giro completo), caso Z = 0 --> Retorna para o loop da esquerda
    GOTO LUDIREITA    ; Loop até o giro acabar
    GOTO NSABO        ; Volta pro NSABO
    
;===================================================;
;	       FUNÇÃO PARA INCREMENTAR OS PASSOS	    ;
;===================================================;	        
PASSO_D:
    INC CPASSO_D
    GOTO FRENTE
;---------------------------------------------------;
PASSO_E:
    INC CPASSO_E
    GOTO FRENTE
;===================================================;   
        
 
;===================================================;
;                   MELHOR CAMINHO                  ;
;===================================================;	        
 
 ; lógica: subtrair os dois passos: PASSO_ESQUERDA´- PASSO_DIREITA -> se for maior que zero, o menor caminho é a direita e vice-versa.
 
 MOVLW  CPASSO_D      ;W = CPASSO_D
 SUBLW  CPASSO_E      ;W =C_PASSO_E - CPASSO_D
 
 ; temos duas opções, se PASSO_ESQUERDA > PASSO_DIREITA, W > 0 e CARRY = 0, caso contrário CARRY = 1
 BTFSS STATUS, Z ; se PASSO_ESQUERDA = PASSO_DIREITA, Z = 1
 GOTO  VOUVER                ; tanto faz
 
 ; se chegou aqui, os valores são diferentes...
 BTFSS STATUS, C ; se ESQ > DIR, C = 1
 GOTO MENOR_ESQ
 
 ; se chegou aqui, a direita foi menor...
 BSF PORTB, 7
 GOTO FRENTE
 
 
 MENOR_ESQ:
    BCF PORTB, 7
    GOTO FRENTE
    
    
END
